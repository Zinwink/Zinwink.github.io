<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git的基本使用</title>
    <link href="/2025/04/17/Git/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/04/17/Git/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 初始化仓库， 生成.git目录</span><br>git init<br><span class="hljs-comment"># 查看仓库状态</span><br>git status<br><span class="hljs-comment"># 向暂存区添加文件</span><br>git add &lt;file&gt;<br><span class="hljs-comment"># 保存仓库的历史记录 -m 指定单行描述</span><br>git commit -m <span class="hljs-string">&#x27;description&#x27;</span><br>git commit <span class="hljs-comment"># 后期对应更改提供描述</span><br><span class="hljs-comment"># 查看提交日志</span><br>git <span class="hljs-built_in">log</span> <span class="hljs-comment"># 只能查看当前状态为终点的历史日志</span><br>git <span class="hljs-built_in">log</span> --pretty=short <span class="hljs-comment"># 只显示提交信息的第一行</span><br>git <span class="hljs-built_in">log</span> README.md <span class="hljs-comment"># 查看指定目录/文件日志</span><br>git <span class="hljs-built_in">log</span> -p <span class="hljs-comment"># 显示文件的改动</span><br>git <span class="hljs-built_in">log</span> -p README.md <br><span class="hljs-comment"># 查看更改前后的差别</span><br><span class="hljs-comment">## 查看工作树和暂存区的差别</span><br>git diff<br><span class="hljs-comment">## 查看工作树和最新提交的差别</span><br><span class="hljs-comment">## 查看本次提交于上次提交之间的差别</span><br>git diff HEAD<br></code></pre></td></tr></table></figure><h1 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h1><p>在进行多个并行作业时。 会用到分支。在并行开发过程中，往往同时存在多个最新代码状态。不同分支中，可以同时进行完全不同的作业。 等该分支的作业完成之后再与master分支合并。</p><h2 id="显示分支一览表"><a href="#显示分支一览表" class="headerlink" title="显示分支一览表"></a>显示分支一览表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><p>“*”表示当前分支</p><h2 id="创建切换分支"><a href="#创建切换分支" class="headerlink" title="创建切换分支"></a>创建切换分支</h2><p>以当前master分支为接触创建新分支使用<code>git checkout -b</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到 feature-A分支并进行提交</span><br>git checkout -b feature-A<br><span class="hljs-comment"># 上面也相当于：创建分支并切换分支</span><br>git branch feature-A<br>git checkout feature-A<br></code></pre></td></tr></table></figure><p>切换为上一个分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -<br></code></pre></td></tr></table></figure><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p><code>git merge</code>命令合并分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先切换到 master分支</span><br>git checkout master<br><span class="hljs-comment"># 合并 再历史记录中明确记录下本次分支合并</span><br>git merge --no-ff feature-A<br></code></pre></td></tr></table></figure><h2 id="以图表形式查看分支"><a href="#以图表形式查看分支" class="headerlink" title="以图表形式查看分支"></a>以图表形式查看分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --graph<br></code></pre></td></tr></table></figure><h1 id="更改提交的操作"><a href="#更改提交的操作" class="headerlink" title="更改提交的操作"></a>更改提交的操作</h1><h2 id="回溯历史版本"><a href="#回溯历史版本" class="headerlink" title="回溯历史版本"></a>回溯历史版本</h2><p><code>git reset</code>命令</p><p>回溯到创建feature-A分支前: <code>git reset --hard </code>并提供目标时间点的哈希值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 回溯到状态</span><br>git reset --hard fd0cbf0d4a25f747230694d95cac1be72d33441d&lt;哈希值&gt;<br><span class="hljs-comment"># 该状态下创建分支fix-B, 并提交进入</span><br>git checkout -b fix-B<br></code></pre></td></tr></table></figure><h2 id="推进至feature-A分支合并后的状态"><a href="#推进至feature-A分支合并后的状态" class="headerlink" title="推进至feature-A分支合并后的状态"></a>推进至feature-A分支合并后的状态</h2><p><code>git log</code>只显示以当前状态为结束的日志，需要使用<code>git reflog</code>查看当前仓库的操作日志，在日志中找出回溯历史之前的哈希值， 通过<code>git reset --hard</code>回溯之前的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前仓库执行过的操作日志</span><br>git reflog <br><br>git checkout master<br>git reset --hard 83b094<br></code></pre></td></tr></table></figure><h2 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h2><p>修改上一条提交信息，使用<code>git commit --amend</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -amend<br></code></pre></td></tr></table></figure><h2 id="压缩历史"><a href="#压缩历史" class="headerlink" title="压缩历史"></a>压缩历史</h2><p><code>git rebase -i</code>命令。 在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录。</p><p>将修正的内容与前一次提交合并，再历史记录中合并为一次完美的提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># HEAD~2选定最新提交在内的两个最新历史记录为对象</span><br>git rebase -i HEAD~2<br><span class="hljs-comment"># 打开编辑器，将要被合并是删除的提交信息的首部pick删除，改写为fixup， 从而将该信息压缩到上一个提交中</span><br></code></pre></td></tr></table></figure><h1 id="推送至远程仓库"><a href="#推送至远程仓库" class="headerlink" title="推送至远程仓库"></a>推送至远程仓库</h1><h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><p><code>git remote add</code>命令。<br>在 GitHub 上创建的仓库路径为<code>git@github.com:用户名/git-tutorial.git</code>。现在我们用<code>git remote add</code>命令将它设置成本地仓库的远程仓库.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin git@github.com:github-book/git-tutorial.git<br></code></pre></td></tr></table></figure><h2 id="推送至远程仓库-1"><a href="#推送至远程仓库-1" class="headerlink" title="推送至远程仓库"></a>推送至远程仓库</h2><p><code>git push</code>命令，将本地仓库中的内容推送给远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将当前分支的内容推送至远程仓库origin的 master分支</span><br><span class="hljs-comment"># -u参数可以在推送的同时，将 origin 仓库的master分支设置为本地仓库当前分支的 upstream（上游）</span><br><span class="hljs-comment"># 添加了这个参数，将来</span><br><span class="hljs-comment"># 运行 git pull命令从远程仓库获取内容时，本地仓库的这个分支就可</span><br><span class="hljs-comment"># 以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦</span><br>git push -u origin master<br></code></pre></td></tr></table></figure><h3 id="推送至master以外的分支"><a href="#推送至master以外的分支" class="headerlink" title="推送至master以外的分支"></a>推送至master以外的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 本地创建feature-D分支</span><br>git checkout -b feature-D<br><span class="hljs-comment"># 推送远程仓库</span><br>git push -u origin feature-D<br></code></pre></td></tr></table></figure><h1 id="从远程仓库中获取"><a href="#从远程仓库中获取" class="headerlink" title="从远程仓库中获取"></a>从远程仓库中获取</h1><h2 id="获取远程仓库"><a href="#获取远程仓库" class="headerlink" title="获取远程仓库"></a>获取远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:github-book/git-tutorial.git<br><br><span class="hljs-comment"># 查看当前分支的相关信息， -a 可以同时显示本地仓库和远程仓库的分支信息</span><br>git branch -a<br></code></pre></td></tr></table></figure><h2 id="获取远程的特定分支"><a href="#获取远程的特定分支" class="headerlink" title="获取远程的特定分支"></a>获取远程的特定分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将feature-D分支获取至本地仓库</span><br>git checkout -b feature-D origin/feature-D<br></code></pre></td></tr></table></figure><h2 id="获取最新的远程仓库分支"><a href="#获取最新的远程仓库分支" class="headerlink" title="获取最新的远程仓库分支"></a>获取最新的远程仓库分支</h2><p><code>git pull</code>命令。这边的本地仓库中只创建了 feature-D 分支，并没有在 feature-D 分支中进行任何提交。然而远程仓库的 feature-D 分支中已经有了我们刚刚推送的提交。这时我们就可以使用 git pull 命令，将本地的 feature-D 分支更新到最新状态。当前分支为 feature-D 分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin feature-D<br></code></pre></td></tr></table></figure><h2 id="获取远程仓库的更新"><a href="#获取远程仓库的更新" class="headerlink" title="获取远程仓库的更新"></a>获取远程仓库的更新</h2><p><code>git featch</code>命令，获取远程更新数据，但不合并到当前分支，不会改变分支内容。<code>git pull</code>会获取变化，并合并到当前分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git pull 相当于 git fetch + git merge</span><br><span class="hljs-comment"># 拉取存放到temp分支</span><br>git fetch origin master:temp <br><span class="hljs-comment"># 显示区别</span><br>git diff temp<br><span class="hljs-comment"># 删除分支</span><br>git branch -d temp<br><span class="hljs-comment"># 合并fetch的分支</span><br>git merge origin/master<br>git merge temp<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python高性能trick</title>
    <link href="/2025/04/17/Python/python%E9%AB%98%E6%80%A7%E8%83%BDtrick/"/>
    <url>/2025/04/17/Python/python%E9%AB%98%E6%80%A7%E8%83%BDtrick/</url>
    
    <content type="html"><![CDATA[<h1 id="Python命名空间查找"><a href="#Python命名空间查找" class="headerlink" title="Python命名空间查找"></a>Python命名空间查找</h1><p>python查找对象的次序：locals()数组–&gt;globals()字典–&gt;__build_in__查找<br>通过from math import sin写法可以减少查找提高性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sin<br><br><span class="hljs-number">1.</span> math.sin(x) ：将查找math, sin<br><span class="hljs-number">2.</span> sin(x) ： 直接从全局名称空间中查找sin<br><span class="hljs-number">3.</span> sin=math.sin<br>   <span class="hljs-keyword">while</span> true:<br> sin(x)<br>使用局部变量指向math.sin, 从<span class="hljs-built_in">locals</span>()中查找，速度相对较快<br></code></pre></td></tr></table></figure><h1 id="Python生成器替代列表减少内存占用"><a href="#Python生成器替代列表减少内存占用" class="headerlink" title="Python生成器替代列表减少内存占用"></a>Python生成器替代列表减少内存占用</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci_gen</span>(<span class="hljs-params">num_items</span>):<br>a,b=<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> num_items:<br><span class="hljs-keyword">yield</span> a <span class="hljs-comment"># 生成器</span><br>a,b=b,a+b<br>num_items-=<span class="hljs-number">1</span><br><br>num=<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> fibonacci_gen(<span class="hljs-number">100000</span>) <span class="hljs-keyword">if</span> n%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h1 id="使用numpy进行加速"><a href="#使用numpy进行加速" class="headerlink" title="使用numpy进行加速"></a>使用numpy进行加速</h1><p>使用Numpy可提高运行速度。减少数据内存的拷贝，可进一步提高速度。（如必要时使用+&#x3D;在内存上直接操作，减少内存的申请，减少缓存缺失，加快速度）</p><h1 id="使用numexpr"><a href="#使用numexpr" class="headerlink" title="使用numexpr"></a>使用numexpr</h1><p>numpy计算的缺点是，执行向量操作A * B+C时，首先将执行操作A * B,并将结果存放在一个临时向量中，在将这个临时向量与C相加。</p><p>numexpr模块可以将向量表达式编译为效率极高的代码，减少高速缓存缺失和占用的临时空间。另外numexpr还可充分利用多个CPU核心，支持OpenMP</p><p>对于大数据类型有效(numexpr会引入额外机制开销。数据较小时，高速缓存可容纳所有数据，引入的额外机制只会加大开销，减小速度)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">evaluate()函数的使用<br>ne.evaluate(<span class="hljs-string">&quot;out*D*dt+grid&quot;</span>, out=out)  指定将结果存在已经预先分配好的数组中<br></code></pre></td></tr></table></figure><p>使用numexpr可以减少numpy运算过程中生成的临时对象，从而减少内存开销。</p><h1 id="Pandas库"><a href="#Pandas库" class="headerlink" title="Pandas库"></a>Pandas库</h1><p>使用apply函数，使用raw&#x3D;true等。需要进一步了解接口用法。 配合编译和并行优化，可以进一步加速。</p><h1 id="编译为C代码"><a href="#编译为C代码" class="headerlink" title="编译为C代码"></a>编译为C代码</h1><p>Cython, Numba, PyPy等工具。对于使用的Numpy等库，没有必要编译为C代码，其本身速度已经足够快，主要编译Python代码实现的CPU计算密集的场景。</p><p>创建pyx文件，并对Python函数的类型进行标注，如浮点型double, 浮点复数double complex等，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_z</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> maxiter, zs, cs</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Calculate output list using Julia update rule&quot;&quot;&quot;</span><br>    cdef unsigned <span class="hljs-built_in">int</span> i, n<br>    cdef double <span class="hljs-built_in">complex</span> z, c<br>    output = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(zs)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(zs)):<br>        n = <span class="hljs-number">0</span><br>        z = zs[i]<br>        c = cs[i]<br>        <span class="hljs-keyword">while</span> n &lt; maxiter <span class="hljs-keyword">and</span> (z.real * z.real + z.imag * z.imag) &lt; <span class="hljs-number">4</span>:<br>            z = z * z + c<br>            n += <span class="hljs-number">1</span><br>        output[i] = n<br>    <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><p>之后创建setup.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup<br><span class="hljs-keyword">from</span> Cython.Build <span class="hljs-keyword">import</span> cythonize<br>setup(ext_modules=cythonize(<span class="hljs-string">&quot;cythonfn.pyx&quot;</span>, compiler_directives=&#123;<span class="hljs-string">&quot;language_level&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>&#125;))<br></code></pre></td></tr></table></figure><p>运行setup.py进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python setup.py build_ext --inplace<br></code></pre></td></tr></table></figure><p>在python文件中调用该c语言编译好的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cythonfn<br>cythonfn.calculate_z() <span class="hljs-comment">#调用</span><br></code></pre></td></tr></table></figure><p>可以使用pyximport自动编译 调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pyximport<br>pyimport.install(language_level=<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">import</span> cythonfn <span class="hljs-comment">#编译好的模块</span><br></code></pre></td></tr></table></figure><p><strong>查看pyx文件的Python虚拟机调用</strong><br>使用 cython -a cythonfn.pyx 命令查看效果， 黄色越深代表Python虚拟机调用的越多。</p><p><strong>开启OpenMP</strong><br>使用prange</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#cython: boundscheck=False</span><br><span class="hljs-keyword">from</span> cython.parallel <span class="hljs-keyword">import</span> parallel, prange<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>cimport numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_z</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> maxiter, double <span class="hljs-built_in">complex</span>[:] zs, double <span class="hljs-built_in">complex</span>[:] cs</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Calculate output list using Julia update rule&quot;&quot;&quot;</span><br>    cdef unsigned <span class="hljs-built_in">int</span> i, length<br>    cdef double <span class="hljs-built_in">complex</span> z, c<br>    cdef <span class="hljs-built_in">int</span>[:] output = np.empty(<span class="hljs-built_in">len</span>(zs), dtype=np.int32)<br>    length = <span class="hljs-built_in">len</span>(zs)<br>    <span class="hljs-keyword">with</span> nogil, parallel():<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> prange(length, schedule=<span class="hljs-string">&quot;guided&quot;</span>):  <span class="hljs-comment"># 使用prange并行化</span><br>            z = zs[i]<br>            c = cs[i]<br>            output[i] = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> output[i] &lt; maxiter <span class="hljs-keyword">and</span> (z.real * z.real + z.imag * z.imag) &lt; <span class="hljs-number">4</span>:<br>                z = z * z + c<br>                output[i] += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># setup.py</span><br><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup<br><br><span class="hljs-keyword">from</span> setuptools.extension <span class="hljs-keyword">import</span> Extension<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>ext_modules = [Extension(<br>      <span class="hljs-string">&quot;cythonfn&quot;</span>,<br>      [<span class="hljs-string">&quot;cythonfn.pyx&quot;</span>],<br>      extra_compile_args=[<span class="hljs-string">&#x27;-fopenmp&#x27;</span>],<br>      extra_link_args=[<span class="hljs-string">&#x27;-fopenmp&#x27;</span>],<br>      )]<br><br><span class="hljs-keyword">from</span> Cython.Build <span class="hljs-keyword">import</span> cythonize<br>setup(ext_modules=cythonize(ext_modules, compiler_directives=&#123;<span class="hljs-string">&quot;language_level&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>&#125;,),include_dirs=[np.get_include()]) <span class="hljs-comment"># 包含numpy的头文件</span><br></code></pre></td></tr></table></figure><h1 id="语言交互接口-调用C库"><a href="#语言交互接口-调用C库" class="headerlink" title="语言交互接口(调用C库)"></a>语言交互接口(调用C库)</h1><p>使用 ctypes或者cffi ，python模块。(cffi使用较为简单)</p><h2 id="cffi-内嵌c代码"><a href="#cffi-内嵌c代码" class="headerlink" title="cffi 内嵌c代码"></a>cffi 内嵌c代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> cffi <span class="hljs-keyword">import</span> FFI, verifier<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>grid_shape = (<span class="hljs-number">512</span>, <span class="hljs-number">512</span>)<br>ffi = FFI()<br>ffi.cdef(<span class="hljs-string">&quot;void evolve(double **in, double **out, double D, double dt);&quot;</span>) <span class="hljs-comment">#包含函数声明，结构体声明等 声明对应下面的verify中的内容(可以包含函数库头文件中的某个函数声明)</span><br>lib = ffi.verify(<br>    <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">    void evolve(double in[][512], double out[][512], double D, double dt) &#123;</span><br><span class="hljs-string">        int i, j;</span><br><span class="hljs-string">        double laplacian;</span><br><span class="hljs-string">        for (i=1; i&lt;511; i++) &#123;</span><br><span class="hljs-string">            for (j=1; j&lt;511; j++) &#123;</span><br><span class="hljs-string">                laplacian = in[i+1][j] + in[i-1][j] + in[i][j+1] + in[i][j-1] - 4 * in[i][j];</span><br><span class="hljs-string">                out[i][j] = in[i][j] + D * dt * laplacian;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;   #verify中可以包含头文件</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>,<br>    extra_compile_args=[<span class="hljs-string">&quot;-O3&quot;</span>],  <span class="hljs-comment"># &lt;1&gt; 编译参数</span><br>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evolve</span>(<span class="hljs-params">grid, dt, out, D=<span class="hljs-number">1.0</span></span>):<br><span class="hljs-comment"># 调用时需要类型转换为c语言函数参数的类型</span><br>    pointer_grid = ffi.cast(<span class="hljs-string">&quot;double**&quot;</span>, grid.ctypes.data)<br>    pointer_out = ffi.cast(<span class="hljs-string">&quot;double**&quot;</span>, out.ctypes.data)<br>    lib.evolve(pointer_grid, pointer_out, D, dt)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_experiment</span>(<span class="hljs-params">num_iterations</span>):<br>    scratch = np.zeros(grid_shape, dtype=np.double)<br>    grid = np.zeros(grid_shape, dtype=np.double)<br>    block_low = <span class="hljs-built_in">int</span>(grid_shape[<span class="hljs-number">0</span>] * <span class="hljs-number">0.4</span>)<br>    block_high = <span class="hljs-built_in">int</span>(grid_shape[<span class="hljs-number">0</span>] * <span class="hljs-number">0.5</span>)<br>    grid[block_low:block_high, block_low:block_high] = <span class="hljs-number">0.005</span><br>    start = time.time()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_iterations):<br>        evolve(grid, <span class="hljs-number">0.1</span>, scratch)<br>        grid, scratch = scratch, grid<br>    <span class="hljs-keyword">return</span> time.time() - start<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    t = run_experiment(<span class="hljs-number">500</span>)<br>    <span class="hljs-built_in">print</span>(t)<br>    verifier.cleanup_tmpdir()<br></code></pre></td></tr></table></figure><h2 id="调用-so库"><a href="#调用-so库" class="headerlink" title="调用.so库"></a>调用.so库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通过gcc编译获得相关的.so文件</span><br>gcc -shared -o diffusion.so diffusion.c -O3 <br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python2.7</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> cffi <span class="hljs-keyword">import</span> FFI, verifier<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>grid_shape = (<span class="hljs-number">512</span>, <span class="hljs-number">512</span>)<br>ffi = FFI()<br>ffi.cdef(<span class="hljs-string">&quot;void evolve(double **in, double **out, double D, double dt);&quot;</span>)  <span class="hljs-comment"># &lt;1&gt;</span><br>lib = ffi.dlopen(<span class="hljs-string">&quot;07_compiling\cffi\diffusion.so&quot;</span>) <span class="hljs-comment">#注意相对路径，最好使用vscode复制，是相对工作目录的路径(当py文件和.so文件在同一目录下时，使用./diffusion.so作为路径,发现无法找到该库)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evolve</span>(<span class="hljs-params">grid, dt, out, D=<span class="hljs-number">1.0</span></span>):<br>    pointer_grid = ffi.cast(<span class="hljs-string">&quot;double**&quot;</span>, grid.ctypes.data)  <span class="hljs-comment"># &lt;2&gt;</span><br>    pointer_out = ffi.cast(<span class="hljs-string">&quot;double**&quot;</span>, out.ctypes.data)<br>    lib.evolve(pointer_grid, pointer_out, D, dt)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_experiment</span>(<span class="hljs-params">num_iterations</span>):<br>    scratch = np.zeros(grid_shape, dtype=np.double)<br>    grid = np.zeros(grid_shape, dtype=np.double)<br>    block_low = <span class="hljs-built_in">int</span>(grid_shape[<span class="hljs-number">0</span>] * <span class="hljs-number">0.4</span>)<br>    block_high = <span class="hljs-built_in">int</span>(grid_shape[<span class="hljs-number">0</span>] * <span class="hljs-number">0.5</span>)<br>    grid[block_low:block_high, block_low:block_high] = <span class="hljs-number">0.005</span><br>    start = time.time()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_iterations):<br>        evolve(grid, <span class="hljs-number">0.1</span>, scratch)<br>        grid, scratch = scratch, grid<br>    <span class="hljs-keyword">return</span> time.time() - start<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    t = run_experiment(<span class="hljs-number">500</span>)<br>    <span class="hljs-built_in">print</span>(t)<br>    verifier.cleanup_tmpdir()<br></code></pre></td></tr></table></figure><h1 id="使用array-标准库-减少占用-且适合多线程数据传送"><a href="#使用array-标准库-减少占用-且适合多线程数据传送" class="headerlink" title="使用array(标准库)减少占用,且适合多线程数据传送"></a>使用array(标准库)减少占用,且适合多线程数据传送</h1><p>array模块可以高效存储基本数据类型，如整数、浮点数和字符，但不能高效地存储复数和类。它分配了一个连续地内存块存储底层数据。（列表会占用过多内存）</p><h1 id="在内存中高效存储大量文本"><a href="#在内存中高效存储大量文本" class="headerlink" title="在内存中高效存储大量文本"></a>在内存中高效存储大量文本</h1><h2 id="字典树压缩等"><a href="#字典树压缩等" class="headerlink" title="字典树压缩等"></a>字典树压缩等</h2><p>可使用字典树压缩，DAWG，Marisa字典树等(通过共享相同内容部分压缩)。<br>在字符串集合中，很多字符串的某些部分是相同的，使用字典树和DAWG可以减少内存占用。</p><p>DAWG在构建后不能修改，其通过一个的迭代器构建。</p><h2 id="scikit-learn-中FeatureHasher"><a href="#scikit-learn-中FeatureHasher" class="headerlink" title="scikit-learn 中FeatureHasher"></a>scikit-learn 中FeatureHasher</h2><p>DictVectorizer接受一个包含词汇和频次的字典，并将其转换为一个变宽的稀疏矩阵。<br>FeatureHasher将包含词汇和频次的字典转换为宽度固定的稀疏矩阵。</p><h1 id="使用SciPy的稀疏矩阵表示减少内存"><a href="#使用SciPy的稀疏矩阵表示减少内存" class="headerlink" title="使用SciPy的稀疏矩阵表示减少内存"></a>使用SciPy的稀疏矩阵表示减少内存</h1><p>当稀疏度很大时(非0元素很少)，占用的内存少且使用专门的算法，运算效率也高。</p><h1 id="使用异步I-O"><a href="#使用异步I-O" class="headerlink" title="使用异步I&#x2F;O"></a>使用异步I&#x2F;O</h1><p>I&#x2F;O是程序执行的巨大负担。每当从文件读取数据或者将数据写入网络套接字时，代码都必须暂停，以等待内核与外部联系，I&#x2F;O完毕后才能执行后继操作。并发式异步编程，通过在I&#x2F;O等待的时间段内执行其他操作，从而缩短程序的执行时间。</p><h1 id="multiprocessing-Joblib模块"><a href="#multiprocessing-Joblib模块" class="headerlink" title="multiprocessing,Joblib模块"></a>multiprocessing,Joblib模块</h1><p>使用并行的方式进行加速。Joblib专为科学计算设计</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
