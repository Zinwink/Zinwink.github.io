<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>二分查找以及lower_bound,upper_bound的实现</title>
    <link href="/2025/04/18/Algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%BB%A5%E5%8F%8A%E4%B8%8A%E4%B8%8B%E7%95%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2025/04/18/Algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%BB%A5%E5%8F%8A%E4%B8%8A%E4%B8%8B%E7%95%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找，按照区间类型可以分为左闭右开、左闭右闭合、左开右闭这几种。 一般常见左闭右开、左闭右闭合两种写法。<br><strong>推荐使用左闭右开的方式实现</strong><br>下面讲解二分查找，找不到返回-1</p><h2 id="左闭右闭写法"><a href="#左闭右闭写法" class="headerlink" title="左闭右闭写法"></a>左闭右闭写法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">midSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> target)</span><br>&#123;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span>  n-<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">while</span>(left&lt;=right)<br>   &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right-left)/<span class="hljs-number">2</span>; <span class="hljs-comment">//mid下取整</span><br>      <span class="hljs-keyword">if</span> (arr[mid]==target)<br>      &#123;<br>        <span class="hljs-keyword">return</span> mid;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid]&lt;target)<br>      &#123;<br>        left = mid + <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span>&#123;<br>        right = mid -<span class="hljs-number">1</span>;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="左闭右开写法"><a href="#左闭右开写法" class="headerlink" title="左闭右开写法"></a>左闭右开写法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">midSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> target)</span><br>&#123;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span>  n;<br>   <span class="hljs-keyword">while</span>(left&lt;right) <span class="hljs-comment">// 不同点</span><br>   &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right-left)/<span class="hljs-number">2</span>; <span class="hljs-comment">//mid上取整</span><br>      <span class="hljs-keyword">if</span> (arr[mid]==target)<br>      &#123;<br>        <span class="hljs-keyword">return</span> mid;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid]&lt;target)<br>      &#123;<br>        left = mid + <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span>&#123;<br>        right = mid; <span class="hljs-comment">//不同点</span><br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分查找进行上下界"><a href="#二分查找进行上下界" class="headerlink" title="二分查找进行上下界"></a>二分查找进行上下界</h1><p>推荐采用左闭右开的写法。(推荐统一采用左闭右开的方法编写， 符合直觉，容易理解)</p><h2 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a><code>lower_bound</code></h2><p><code>lower_bound</code>即为求解第一个大于等于target的数的下标(如果有等于，则返回第一个等于该数的下标)。</p><ol><li>使用左闭右开的方式寻找</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">lower_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> target)</span><br>&#123;<br>    <span class="hljs-comment">// [left,right)</span><br>    <span class="hljs-keyword">while</span>(left&lt;right)<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid]&lt;target)<br>        &#123;   <span class="hljs-comment">// 寻找大于等于的</span><br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">//left 收缩</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            right = mid;  <span class="hljs-comment">//right边界收缩</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>使用左闭右闭的方式寻找</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">lower_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> target)</span><br>&#123;<br>    <span class="hljs-comment">// [left,right]</span><br>    <span class="hljs-keyword">while</span>(left&lt;=right) <span class="hljs-comment">//保证区间不空</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid]&lt;target) <span class="hljs-comment">//不同点</span><br>        &#123;   <span class="hljs-comment">// 保证区间外部全部为已知大小关系的元素，所以现在未知区间的为[left, right]</span><br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">//left 收缩</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 因为要找&gt;=target的元素，所以当所查找的mid值为target时，应将相等的部分放到未知区间的右边</span><br>            right = mid - <span class="hljs-number">1</span>;  <span class="hljs-comment">//right边界收缩</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a><code>upper_bound</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">upper_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> target)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(left&lt;right)<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid]&gt;target)<br>        &#123;<br>            right = mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            left = mid +<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">//left==right时停止，right取得是&gt;target的</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Reference</strong><br>[1] <a href="https://www.zhihu.com/question/36132386/answer/530313852">二分查找有几种写法？它们的区别是什么？</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python中切片操作以及索引操作和以及相关注意事项</title>
    <link href="/2025/04/18/Python/python%E4%B8%AD%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2025/04/18/Python/python%E4%B8%AD%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-中-切片操作注意事项"><a href="#Python-中-切片操作注意事项" class="headerlink" title="Python 中 切片操作注意事项"></a>Python 中 切片操作注意事项</h1><h2 id="list-切片操作"><a href="#list-切片操作" class="headerlink" title="list 切片操作"></a>list 切片操作</h2><ol><li>内存独立性： 原列表和通过切片得到的新列表在内存中是分开的。 修改其中一个不会影响另一个</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Cpp">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <br>b = a[:<span class="hljs-number">2</span>] <span class="hljs-meta"># b 是 [1, 2] </span><br>b.<span class="hljs-built_in">append</span>(<span class="hljs-number">5</span>) # 修改 b 不会影响 a <br><span class="hljs-built_in">print</span>(a) # 输出: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <br><span class="hljs-built_in">print</span>(b) # 输出: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><ol start="2"><li>浅拷贝： 列表中包含的引用类型，都是进行浅拷贝，内部对象不会进行深拷贝</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Cpp">a = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br>b = a[:<span class="hljs-number">1</span>] <span class="hljs-meta"># b 包含 a 的第一个子列表的引用</span><br>b[<span class="hljs-number">0</span>].<span class="hljs-built_in">append</span>(<span class="hljs-number">5</span>) # 这将影响到 a 中对应子列表的内容<br><span class="hljs-built_in">print</span>(a) # 输出: [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br></code></pre></td></tr></table></figure><ol start="3"><li>会影响的情形 赋值：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">-----------------------------修改<br>view_shape = [<span class="hljs-number">64</span>, <span class="hljs-number">128</span>,<span class="hljs-number">128</span>]<br><span class="hljs-comment"># view_shape[1:] = [1] * (len(view_shape) - 1)</span><br>view_shape[<span class="hljs-number">1</span>:] = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(view_shape) <span class="hljs-comment"># [64, 1, 1, 1]</span><br>---------------------------不修改<br>view_shape = [<span class="hljs-number">64</span>, <span class="hljs-number">128</span>,<span class="hljs-number">128</span>]<br><span class="hljs-comment"># view_shape[1:] = [1] * (len(view_shape) - 1)</span><br>view_shape[<span class="hljs-number">1</span>:][<span class="hljs-number">0</span>] = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(view_shape)  <span class="hljs-comment"># [64, 128, 128]</span><br></code></pre></td></tr></table></figure><h2 id="numpy-数组切片操作"><a href="#numpy-数组切片操作" class="headerlink" title="numpy 数组切片操作"></a>numpy 数组切片操作</h2><ol><li>Numpy 尽量避免复制数据以提高效率。因此许多切片返回的是原始数据的一个视图，这意味着对视图所做的修改会影响到原始数组</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">import</span> numpy as np<br>arr = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>view = arr[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] # 这是一个视图<br>view[<span class="hljs-number">0</span>] = <span class="hljs-number">999</span> # 修改视图会影响原数组<br><span class="hljs-built_in">print</span>(arr) # 输出: [ <span class="hljs-number">1</span> <span class="hljs-number">999</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>pytorch Tensor的切片操作和 numpy切片操作相似，都是返回一个视图</p><h1 id="Python-引用类型传参注意事项"><a href="#Python-引用类型传参注意事项" class="headerlink" title="Python 引用类型传参注意事项"></a>Python 引用类型传参注意事项</h1><p>Python 引用类型作为函数参数时，传递的是对象的引用地址。 和C&#x2F;C++中指针的传参类似， C++中传递的是指针的副本(指向相同内存对象， 但是是不同指针，是原指针的副本， 修改指向不会影响原指针)。 </p><ol><li>非引用类型</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">modify_immutable</span>(<span class="hljs-params">x</span>): <br>x = x + <span class="hljs-number">1</span> <span class="hljs-comment"># 尝试修改 x </span><br><br>a = <span class="hljs-number">5</span> <br>modify_immutable(a) <br><span class="hljs-built_in">print</span>(a) <span class="hljs-comment"># 输出: 5，原始变量 a 没有变化</span><br></code></pre></td></tr></table></figure><ol start="2"><li>引用类型(不对引用的内存对象操作， 只对引用操作时， 只是引用副本的指向变化， 原引用不受影响)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reassign_mutable</span>(<span class="hljs-params">lst</span>): <br><span class="hljs-comment"># lst 是引用副本， 下面是修改引用的指向</span><br>lst = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>] <span class="hljs-comment"># 这里是重新赋值，不是修改原列表 </span><br><br>my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>reassign_mutable(my_list) <br><span class="hljs-built_in">print</span>(my_list) <span class="hljs-comment"># 输出: [1, 2, 3]，原始列表 my_list 没有变化</span><br></code></pre></td></tr></table></figure><h1 id="None-扩展维度，广播机制计算距离矩阵"><a href="#None-扩展维度，广播机制计算距离矩阵" class="headerlink" title="None 扩展维度，广播机制计算距离矩阵"></a>None 扩展维度，广播机制计算距离矩阵</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">square_distance</span>(<span class="hljs-params">src, dst</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Calculate Euclid distance between each two points.</span><br><span class="hljs-string">    src^T * dst = xn * xm + yn * ym + zn * zm；</span><br><span class="hljs-string">    sum(src^2, dim=-1) = xn*xn + yn*yn + zn*zn;</span><br><span class="hljs-string">    sum(dst^2, dim=-1) = xm*xm + ym*ym + zm*zm;</span><br><span class="hljs-string">    dist = (xn - xm)^2 + (yn - ym)^2 + (zn - zm)^2</span><br><span class="hljs-string">         = sum(src**2,dim=-1)+sum(dst**2,dim=-1)-2*src^T*dst</span><br><span class="hljs-string">    Input:</span><br><span class="hljs-string">        src: source points, [B, N, C]</span><br><span class="hljs-string">        dst: target points, [B, M, C]</span><br><span class="hljs-string">    Output:</span><br><span class="hljs-string">        dist: per-point square distance, [B, N, M]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> torch.<span class="hljs-built_in">sum</span>((src[:, :, <span class="hljs-literal">None</span>] - dst[:, <span class="hljs-literal">None</span>]) ** <span class="hljs-number">2</span>, dim=-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="Numpy-Pytorch-索引操作"><a href="#Numpy-Pytorch-索引操作" class="headerlink" title="Numpy Pytorch 索引操作"></a>Numpy Pytorch 索引操作</h1><ol><li>… 选择所有剩余维度</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-comment"># 创建一个形状为 [2, 3, 4] 的张量</span><br>tensor = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment"># 使用 ... 选择所有剩余维度</span><br>expanded_tensor = tensor[..., <span class="hljs-literal">None</span>]<br><span class="hljs-built_in">print</span>(expanded_tensor.shape)  <span class="hljs-comment"># 输出: torch.Size([2, 3, 4, 1])</span><br><span class="hljs-comment"># `tensor[..., None]` 等价于 `tensor[:, :, :, None]`</span><br>---------------------------------------------------------<br><br></code></pre></td></tr></table></figure><h2 id="Pytorch-张量索引"><a href="#Pytorch-张量索引" class="headerlink" title="Pytorch 张量索引"></a>Pytorch 张量索引</h2><ol><li>使用 torch.gather 获取（适用于复杂索引， 多维索引）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">index_points</span>(<span class="hljs-params">points, idx</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Input:</span><br><span class="hljs-string">        points: input points data, [B, N, C]</span><br><span class="hljs-string">        idx: sample index data, [B, S, [K]]</span><br><span class="hljs-string">    Return:</span><br><span class="hljs-string">        new_points:, indexed points data, [B, S, [K], C]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    raw_size = idx.size()<br>    idx = idx.reshape(raw_size[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>)<br>    res = torch.gather(points, <span class="hljs-number">1</span>, idx[..., <span class="hljs-literal">None</span>].expand(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, points.size(-<span class="hljs-number">1</span>)))<br>    <span class="hljs-keyword">return</span> res.reshape(*raw_size, -<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><ol start="2"><li>使用高级索引</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index_points</span>(<span class="hljs-params">points, idx</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Input:</span><br><span class="hljs-string">        points: input points data, [B, N, C]</span><br><span class="hljs-string">        idx: sample index data, [B, S, K]</span><br><span class="hljs-string">    Return:</span><br><span class="hljs-string">        new_points: indexed points data, [B, S, K, C]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 使用高级索引从 points 中提取数据</span><br>    B, S, K = idx.shape<br>    <span class="hljs-comment"># 创建一个范围张量，用于批次索引</span><br>    batch_indices = torch.arange(B).view(B, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 使用高级索引提取数据</span><br>    new_points = points[batch_indices, idx]<br>    <span class="hljs-keyword">return</span> new_points<br><br><span class="hljs-comment"># 示例</span><br>points = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 形状为 [B, N, C]</span><br>idx = torch.tensor([[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]], [[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]]])  <span class="hljs-comment"># 形状为 [B, S, K]</span><br><br>new_points = index_points(points, idx)<br><span class="hljs-built_in">print</span>(new_points.shape)  <span class="hljs-comment"># 输出: torch.Size([2, 2, 3, 3])</span><br><br></code></pre></td></tr></table></figure><ol start="3"><li>使用1维索引(加上适当的偏移量)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index_points</span>(<span class="hljs-params">points, idx</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Input:</span><br><span class="hljs-string">        points: input points data, [B, N, C]</span><br><span class="hljs-string">        idx: sample index data, [B, S, K]</span><br><span class="hljs-string">    Return:</span><br><span class="hljs-string">        new_points: indexed points data, [B, S, K, C]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    B, N, C = points.shape<br>    S, K = idx.shape[<span class="hljs-number">1</span>], idx.shape[<span class="hljs-number">2</span>]<br><br>    <span class="hljs-comment"># 计算偏移量</span><br>    offset = torch.arange(B).view(B, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) * N<br><br>    <span class="hljs-comment"># 计算一维索引</span><br>    flat_idx = idx + offset<br><br>    <span class="hljs-comment"># 使用一维索引提取数据</span><br>    flat_points = points.view(B * N, C)<br>    flat_new_points = flat_points[flat_idx.view(-<span class="hljs-number">1</span>)]<br><br>    <span class="hljs-comment"># 重塑结果</span><br>    new_points = flat_new_points.view(B, S, K, C)<br><br>    <span class="hljs-keyword">return</span> new_points<br><br><span class="hljs-comment"># 示例</span><br>points = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 形状为 [B, N, C]</span><br>idx = torch.tensor([[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]], [[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]]])  <span class="hljs-comment"># 形状为 [B, S, K]</span><br><br>new_points = index_points(points, idx)<br><span class="hljs-built_in">print</span>(new_points.shape)  <span class="hljs-comment"># 输出: torch.Size([2, 2, 3, 3])</span><br></code></pre></td></tr></table></figure><ol><li>torch.index_select()函数 索引张量是一维的</li></ol><h2 id="Pytorch-切片赋值"><a href="#Pytorch-切片赋值" class="headerlink" title="Pytorch 切片赋值"></a>Pytorch 切片赋值</h2><p>切片赋值是在原内存中写入数据， 而不是开辟内存后重新指向新内存空间。（因此和就地操作性能相同）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-comment"># 创建一个张量</span><br>a = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-comment"># 切片, 获得的只是视图</span><br>b = a[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br><br><span class="hljs-comment"># 检查数据指针</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Before assignment:&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a.data_ptr():&quot;</span>, a.data_ptr())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;b.data_ptr():&quot;</span>, b.data_ptr())<br><br><span class="hljs-comment"># 对 b 进行范围切片赋值</span><br>b[:] = torch.tensor([<span class="hljs-number">99</span>, <span class="hljs-number">88</span>, <span class="hljs-number">77</span>])  <span class="hljs-comment"># 使用范围切片赋值</span><br><br><span class="hljs-comment"># 打印结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After assignment:&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a:&quot;</span>, a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;b:&quot;</span>, b)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a.data_ptr():&quot;</span>, a.data_ptr())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;b.data_ptr():&quot;</span>, b.data_ptr())<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Before assignment:<br>a.data_ptr(): 510923136<br>b.data_ptr(): 510923144<br>After assignment:<br>a: tensor([ 1, 99, 88, 77,  5]) <span class="hljs-comment"># 原tensor改变内容</span><br>b: tensor([99, 88, 77])<br>a.data_ptr(): 510923136 <span class="hljs-comment"># 内存指向不变</span><br>b.data_ptr(): 510923144 <span class="hljs-comment"># 内存指向不变</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>pytorch</tag>
      
      <tag>numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git的基本使用</title>
    <link href="/2025/04/17/Git/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/04/17/Git/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 初始化仓库， 生成.git目录</span><br>git init<br><span class="hljs-comment"># 查看仓库状态</span><br>git status<br><span class="hljs-comment"># 向暂存区添加文件</span><br>git add &lt;file&gt;<br><span class="hljs-comment"># 保存仓库的历史记录 -m 指定单行描述</span><br>git commit -m <span class="hljs-string">&#x27;description&#x27;</span><br>git commit <span class="hljs-comment"># 后期对应更改提供描述</span><br><span class="hljs-comment"># 查看提交日志</span><br>git <span class="hljs-built_in">log</span> <span class="hljs-comment"># 只能查看当前状态为终点的历史日志</span><br>git <span class="hljs-built_in">log</span> --pretty=short <span class="hljs-comment"># 只显示提交信息的第一行</span><br>git <span class="hljs-built_in">log</span> README.md <span class="hljs-comment"># 查看指定目录/文件日志</span><br>git <span class="hljs-built_in">log</span> -p <span class="hljs-comment"># 显示文件的改动</span><br>git <span class="hljs-built_in">log</span> -p README.md <br><span class="hljs-comment"># 查看更改前后的差别</span><br><span class="hljs-comment">## 查看工作树和暂存区的差别</span><br>git diff<br><span class="hljs-comment">## 查看工作树和最新提交的差别</span><br><span class="hljs-comment">## 查看本次提交于上次提交之间的差别</span><br>git diff HEAD<br></code></pre></td></tr></table></figure><h1 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h1><p>在进行多个并行作业时。 会用到分支。在并行开发过程中，往往同时存在多个最新代码状态。不同分支中，可以同时进行完全不同的作业。 等该分支的作业完成之后再与master分支合并。</p><h2 id="显示分支一览表"><a href="#显示分支一览表" class="headerlink" title="显示分支一览表"></a>显示分支一览表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><p>“*”表示当前分支</p><h2 id="创建切换分支"><a href="#创建切换分支" class="headerlink" title="创建切换分支"></a>创建切换分支</h2><p>以当前master分支为接触创建新分支使用<code>git checkout -b</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到 feature-A分支并进行提交</span><br>git checkout -b feature-A<br><span class="hljs-comment"># 上面也相当于：创建分支并切换分支</span><br>git branch feature-A<br>git checkout feature-A<br></code></pre></td></tr></table></figure><p>切换为上一个分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -<br></code></pre></td></tr></table></figure><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p><code>git merge</code>命令合并分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先切换到 master分支</span><br>git checkout master<br><span class="hljs-comment"># 合并 再历史记录中明确记录下本次分支合并</span><br>git merge --no-ff feature-A<br></code></pre></td></tr></table></figure><h2 id="以图表形式查看分支"><a href="#以图表形式查看分支" class="headerlink" title="以图表形式查看分支"></a>以图表形式查看分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --graph<br></code></pre></td></tr></table></figure><h1 id="更改提交的操作"><a href="#更改提交的操作" class="headerlink" title="更改提交的操作"></a>更改提交的操作</h1><h2 id="回溯历史版本"><a href="#回溯历史版本" class="headerlink" title="回溯历史版本"></a>回溯历史版本</h2><p><code>git reset</code>命令</p><p>回溯到创建feature-A分支前: <code>git reset --hard </code>并提供目标时间点的哈希值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 回溯到状态</span><br>git reset --hard fd0cbf0d4a25f747230694d95cac1be72d33441d&lt;哈希值&gt;<br><span class="hljs-comment"># 该状态下创建分支fix-B, 并提交进入</span><br>git checkout -b fix-B<br></code></pre></td></tr></table></figure><h2 id="推进至feature-A分支合并后的状态"><a href="#推进至feature-A分支合并后的状态" class="headerlink" title="推进至feature-A分支合并后的状态"></a>推进至feature-A分支合并后的状态</h2><p><code>git log</code>只显示以当前状态为结束的日志，需要使用<code>git reflog</code>查看当前仓库的操作日志，在日志中找出回溯历史之前的哈希值， 通过<code>git reset --hard</code>回溯之前的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前仓库执行过的操作日志</span><br>git reflog <br><br>git checkout master<br>git reset --hard 83b094<br></code></pre></td></tr></table></figure><h2 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h2><p>修改上一条提交信息，使用<code>git commit --amend</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -amend<br></code></pre></td></tr></table></figure><h2 id="压缩历史"><a href="#压缩历史" class="headerlink" title="压缩历史"></a>压缩历史</h2><p><code>git rebase -i</code>命令。 在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录。</p><p>将修正的内容与前一次提交合并，再历史记录中合并为一次完美的提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># HEAD~2选定最新提交在内的两个最新历史记录为对象</span><br>git rebase -i HEAD~2<br><span class="hljs-comment"># 打开编辑器，将要被合并是删除的提交信息的首部pick删除，改写为fixup， 从而将该信息压缩到上一个提交中</span><br></code></pre></td></tr></table></figure><h1 id="推送至远程仓库"><a href="#推送至远程仓库" class="headerlink" title="推送至远程仓库"></a>推送至远程仓库</h1><h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><p><code>git remote add</code>命令。<br>在 GitHub 上创建的仓库路径为<code>git@github.com:用户名/git-tutorial.git</code>。现在我们用<code>git remote add</code>命令将它设置成本地仓库的远程仓库.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin git@github.com:github-book/git-tutorial.git<br></code></pre></td></tr></table></figure><h2 id="推送至远程仓库-1"><a href="#推送至远程仓库-1" class="headerlink" title="推送至远程仓库"></a>推送至远程仓库</h2><p><code>git push</code>命令，将本地仓库中的内容推送给远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将当前分支的内容推送至远程仓库origin的 master分支</span><br><span class="hljs-comment"># -u参数可以在推送的同时，将 origin 仓库的master分支设置为本地仓库当前分支的 upstream（上游）</span><br><span class="hljs-comment"># 添加了这个参数，将来</span><br><span class="hljs-comment"># 运行 git pull命令从远程仓库获取内容时，本地仓库的这个分支就可</span><br><span class="hljs-comment"># 以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦</span><br>git push -u origin master<br></code></pre></td></tr></table></figure><h3 id="推送至master以外的分支"><a href="#推送至master以外的分支" class="headerlink" title="推送至master以外的分支"></a>推送至master以外的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 本地创建feature-D分支</span><br>git checkout -b feature-D<br><span class="hljs-comment"># 推送远程仓库</span><br>git push -u origin feature-D<br></code></pre></td></tr></table></figure><h1 id="从远程仓库中获取"><a href="#从远程仓库中获取" class="headerlink" title="从远程仓库中获取"></a>从远程仓库中获取</h1><h2 id="获取远程仓库"><a href="#获取远程仓库" class="headerlink" title="获取远程仓库"></a>获取远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:github-book/git-tutorial.git<br><br><span class="hljs-comment"># 查看当前分支的相关信息， -a 可以同时显示本地仓库和远程仓库的分支信息</span><br>git branch -a<br></code></pre></td></tr></table></figure><h2 id="获取远程的特定分支"><a href="#获取远程的特定分支" class="headerlink" title="获取远程的特定分支"></a>获取远程的特定分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将feature-D分支获取至本地仓库</span><br>git checkout -b feature-D origin/feature-D<br></code></pre></td></tr></table></figure><h2 id="获取最新的远程仓库分支"><a href="#获取最新的远程仓库分支" class="headerlink" title="获取最新的远程仓库分支"></a>获取最新的远程仓库分支</h2><p><code>git pull</code>命令。这边的本地仓库中只创建了 feature-D 分支，并没有在 feature-D 分支中进行任何提交。然而远程仓库的 feature-D 分支中已经有了我们刚刚推送的提交。这时我们就可以使用 git pull 命令，将本地的 feature-D 分支更新到最新状态。当前分支为 feature-D 分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin feature-D<br></code></pre></td></tr></table></figure><h2 id="获取远程仓库的更新"><a href="#获取远程仓库的更新" class="headerlink" title="获取远程仓库的更新"></a>获取远程仓库的更新</h2><p><code>git featch</code>命令，获取远程更新数据，但不合并到当前分支，不会改变分支内容。<code>git pull</code>会获取变化，并合并到当前分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git pull 相当于 git fetch + git merge</span><br><span class="hljs-comment"># 拉取存放到temp分支</span><br>git fetch origin master:temp <br><span class="hljs-comment"># 显示区别</span><br>git diff temp<br><span class="hljs-comment"># 删除分支</span><br>git branch -d temp<br><span class="hljs-comment"># 合并fetch的分支</span><br>git merge origin/master<br>git merge temp<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python高性能trick</title>
    <link href="/2025/04/17/Python/python%E9%AB%98%E6%80%A7%E8%83%BDtrick/"/>
    <url>/2025/04/17/Python/python%E9%AB%98%E6%80%A7%E8%83%BDtrick/</url>
    
    <content type="html"><![CDATA[<h1 id="Python命名空间查找"><a href="#Python命名空间查找" class="headerlink" title="Python命名空间查找"></a>Python命名空间查找</h1><p>python查找对象的次序：locals()数组–&gt;globals()字典–&gt;__build_in__查找<br>通过from math import sin写法可以减少查找提高性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sin<br><br><span class="hljs-number">1.</span> math.sin(x) ：将查找math, sin<br><span class="hljs-number">2.</span> sin(x) ： 直接从全局名称空间中查找sin<br><span class="hljs-number">3.</span> sin=math.sin<br>   <span class="hljs-keyword">while</span> true:<br> sin(x)<br>使用局部变量指向math.sin, 从<span class="hljs-built_in">locals</span>()中查找，速度相对较快<br></code></pre></td></tr></table></figure><h1 id="Python生成器替代列表减少内存占用"><a href="#Python生成器替代列表减少内存占用" class="headerlink" title="Python生成器替代列表减少内存占用"></a>Python生成器替代列表减少内存占用</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci_gen</span>(<span class="hljs-params">num_items</span>):<br>a,b=<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> num_items:<br><span class="hljs-keyword">yield</span> a <span class="hljs-comment"># 生成器</span><br>a,b=b,a+b<br>num_items-=<span class="hljs-number">1</span><br><br>num=<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> fibonacci_gen(<span class="hljs-number">100000</span>) <span class="hljs-keyword">if</span> n%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h1 id="使用numpy进行加速"><a href="#使用numpy进行加速" class="headerlink" title="使用numpy进行加速"></a>使用numpy进行加速</h1><p>使用Numpy可提高运行速度。减少数据内存的拷贝，可进一步提高速度。（如必要时使用+&#x3D;在内存上直接操作，减少内存的申请，减少缓存缺失，加快速度）</p><h1 id="使用numexpr"><a href="#使用numexpr" class="headerlink" title="使用numexpr"></a>使用numexpr</h1><p>numpy计算的缺点是，执行向量操作A * B+C时，首先将执行操作A * B,并将结果存放在一个临时向量中，在将这个临时向量与C相加。</p><p>numexpr模块可以将向量表达式编译为效率极高的代码，减少高速缓存缺失和占用的临时空间。另外numexpr还可充分利用多个CPU核心，支持OpenMP</p><p>对于大数据类型有效(numexpr会引入额外机制开销。数据较小时，高速缓存可容纳所有数据，引入的额外机制只会加大开销，减小速度)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">evaluate()函数的使用<br>ne.evaluate(<span class="hljs-string">&quot;out*D*dt+grid&quot;</span>, out=out)  指定将结果存在已经预先分配好的数组中<br></code></pre></td></tr></table></figure><p>使用numexpr可以减少numpy运算过程中生成的临时对象，从而减少内存开销。</p><h1 id="Pandas库"><a href="#Pandas库" class="headerlink" title="Pandas库"></a>Pandas库</h1><p>使用apply函数，使用raw&#x3D;true等。需要进一步了解接口用法。 配合编译和并行优化，可以进一步加速。</p><h1 id="编译为C代码"><a href="#编译为C代码" class="headerlink" title="编译为C代码"></a>编译为C代码</h1><p>Cython, Numba, PyPy等工具。对于使用的Numpy等库，没有必要编译为C代码，其本身速度已经足够快，主要编译Python代码实现的CPU计算密集的场景。</p><p>创建pyx文件，并对Python函数的类型进行标注，如浮点型double, 浮点复数double complex等，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_z</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> maxiter, zs, cs</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Calculate output list using Julia update rule&quot;&quot;&quot;</span><br>    cdef unsigned <span class="hljs-built_in">int</span> i, n<br>    cdef double <span class="hljs-built_in">complex</span> z, c<br>    output = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(zs)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(zs)):<br>        n = <span class="hljs-number">0</span><br>        z = zs[i]<br>        c = cs[i]<br>        <span class="hljs-keyword">while</span> n &lt; maxiter <span class="hljs-keyword">and</span> (z.real * z.real + z.imag * z.imag) &lt; <span class="hljs-number">4</span>:<br>            z = z * z + c<br>            n += <span class="hljs-number">1</span><br>        output[i] = n<br>    <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><p>之后创建setup.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup<br><span class="hljs-keyword">from</span> Cython.Build <span class="hljs-keyword">import</span> cythonize<br>setup(ext_modules=cythonize(<span class="hljs-string">&quot;cythonfn.pyx&quot;</span>, compiler_directives=&#123;<span class="hljs-string">&quot;language_level&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>&#125;))<br></code></pre></td></tr></table></figure><p>运行setup.py进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python setup.py build_ext --inplace<br></code></pre></td></tr></table></figure><p>在python文件中调用该c语言编译好的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cythonfn<br>cythonfn.calculate_z() <span class="hljs-comment">#调用</span><br></code></pre></td></tr></table></figure><p>可以使用pyximport自动编译 调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pyximport<br>pyimport.install(language_level=<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">import</span> cythonfn <span class="hljs-comment">#编译好的模块</span><br></code></pre></td></tr></table></figure><p><strong>查看pyx文件的Python虚拟机调用</strong><br>使用 cython -a cythonfn.pyx 命令查看效果， 黄色越深代表Python虚拟机调用的越多。</p><p><strong>开启OpenMP</strong><br>使用prange</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#cython: boundscheck=False</span><br><span class="hljs-keyword">from</span> cython.parallel <span class="hljs-keyword">import</span> parallel, prange<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>cimport numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_z</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> maxiter, double <span class="hljs-built_in">complex</span>[:] zs, double <span class="hljs-built_in">complex</span>[:] cs</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Calculate output list using Julia update rule&quot;&quot;&quot;</span><br>    cdef unsigned <span class="hljs-built_in">int</span> i, length<br>    cdef double <span class="hljs-built_in">complex</span> z, c<br>    cdef <span class="hljs-built_in">int</span>[:] output = np.empty(<span class="hljs-built_in">len</span>(zs), dtype=np.int32)<br>    length = <span class="hljs-built_in">len</span>(zs)<br>    <span class="hljs-keyword">with</span> nogil, parallel():<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> prange(length, schedule=<span class="hljs-string">&quot;guided&quot;</span>):  <span class="hljs-comment"># 使用prange并行化</span><br>            z = zs[i]<br>            c = cs[i]<br>            output[i] = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> output[i] &lt; maxiter <span class="hljs-keyword">and</span> (z.real * z.real + z.imag * z.imag) &lt; <span class="hljs-number">4</span>:<br>                z = z * z + c<br>                output[i] += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># setup.py</span><br><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup<br><br><span class="hljs-keyword">from</span> setuptools.extension <span class="hljs-keyword">import</span> Extension<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>ext_modules = [Extension(<br>      <span class="hljs-string">&quot;cythonfn&quot;</span>,<br>      [<span class="hljs-string">&quot;cythonfn.pyx&quot;</span>],<br>      extra_compile_args=[<span class="hljs-string">&#x27;-fopenmp&#x27;</span>],<br>      extra_link_args=[<span class="hljs-string">&#x27;-fopenmp&#x27;</span>],<br>      )]<br><br><span class="hljs-keyword">from</span> Cython.Build <span class="hljs-keyword">import</span> cythonize<br>setup(ext_modules=cythonize(ext_modules, compiler_directives=&#123;<span class="hljs-string">&quot;language_level&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>&#125;,),include_dirs=[np.get_include()]) <span class="hljs-comment"># 包含numpy的头文件</span><br></code></pre></td></tr></table></figure><h1 id="语言交互接口-调用C库"><a href="#语言交互接口-调用C库" class="headerlink" title="语言交互接口(调用C库)"></a>语言交互接口(调用C库)</h1><p>使用 ctypes或者cffi ，python模块。(cffi使用较为简单)</p><h2 id="cffi-内嵌c代码"><a href="#cffi-内嵌c代码" class="headerlink" title="cffi 内嵌c代码"></a>cffi 内嵌c代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> cffi <span class="hljs-keyword">import</span> FFI, verifier<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>grid_shape = (<span class="hljs-number">512</span>, <span class="hljs-number">512</span>)<br>ffi = FFI()<br>ffi.cdef(<span class="hljs-string">&quot;void evolve(double **in, double **out, double D, double dt);&quot;</span>) <span class="hljs-comment">#包含函数声明，结构体声明等 声明对应下面的verify中的内容(可以包含函数库头文件中的某个函数声明)</span><br>lib = ffi.verify(<br>    <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">    void evolve(double in[][512], double out[][512], double D, double dt) &#123;</span><br><span class="hljs-string">        int i, j;</span><br><span class="hljs-string">        double laplacian;</span><br><span class="hljs-string">        for (i=1; i&lt;511; i++) &#123;</span><br><span class="hljs-string">            for (j=1; j&lt;511; j++) &#123;</span><br><span class="hljs-string">                laplacian = in[i+1][j] + in[i-1][j] + in[i][j+1] + in[i][j-1] - 4 * in[i][j];</span><br><span class="hljs-string">                out[i][j] = in[i][j] + D * dt * laplacian;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;   #verify中可以包含头文件</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>,<br>    extra_compile_args=[<span class="hljs-string">&quot;-O3&quot;</span>],  <span class="hljs-comment"># &lt;1&gt; 编译参数</span><br>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evolve</span>(<span class="hljs-params">grid, dt, out, D=<span class="hljs-number">1.0</span></span>):<br><span class="hljs-comment"># 调用时需要类型转换为c语言函数参数的类型</span><br>    pointer_grid = ffi.cast(<span class="hljs-string">&quot;double**&quot;</span>, grid.ctypes.data)<br>    pointer_out = ffi.cast(<span class="hljs-string">&quot;double**&quot;</span>, out.ctypes.data)<br>    lib.evolve(pointer_grid, pointer_out, D, dt)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_experiment</span>(<span class="hljs-params">num_iterations</span>):<br>    scratch = np.zeros(grid_shape, dtype=np.double)<br>    grid = np.zeros(grid_shape, dtype=np.double)<br>    block_low = <span class="hljs-built_in">int</span>(grid_shape[<span class="hljs-number">0</span>] * <span class="hljs-number">0.4</span>)<br>    block_high = <span class="hljs-built_in">int</span>(grid_shape[<span class="hljs-number">0</span>] * <span class="hljs-number">0.5</span>)<br>    grid[block_low:block_high, block_low:block_high] = <span class="hljs-number">0.005</span><br>    start = time.time()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_iterations):<br>        evolve(grid, <span class="hljs-number">0.1</span>, scratch)<br>        grid, scratch = scratch, grid<br>    <span class="hljs-keyword">return</span> time.time() - start<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    t = run_experiment(<span class="hljs-number">500</span>)<br>    <span class="hljs-built_in">print</span>(t)<br>    verifier.cleanup_tmpdir()<br></code></pre></td></tr></table></figure><h2 id="调用-so库"><a href="#调用-so库" class="headerlink" title="调用.so库"></a>调用.so库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通过gcc编译获得相关的.so文件</span><br>gcc -shared -o diffusion.so diffusion.c -O3 <br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python2.7</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> cffi <span class="hljs-keyword">import</span> FFI, verifier<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>grid_shape = (<span class="hljs-number">512</span>, <span class="hljs-number">512</span>)<br>ffi = FFI()<br>ffi.cdef(<span class="hljs-string">&quot;void evolve(double **in, double **out, double D, double dt);&quot;</span>)  <span class="hljs-comment"># &lt;1&gt;</span><br>lib = ffi.dlopen(<span class="hljs-string">&quot;07_compiling\cffi\diffusion.so&quot;</span>) <span class="hljs-comment">#注意相对路径，最好使用vscode复制，是相对工作目录的路径(当py文件和.so文件在同一目录下时，使用./diffusion.so作为路径,发现无法找到该库)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evolve</span>(<span class="hljs-params">grid, dt, out, D=<span class="hljs-number">1.0</span></span>):<br>    pointer_grid = ffi.cast(<span class="hljs-string">&quot;double**&quot;</span>, grid.ctypes.data)  <span class="hljs-comment"># &lt;2&gt;</span><br>    pointer_out = ffi.cast(<span class="hljs-string">&quot;double**&quot;</span>, out.ctypes.data)<br>    lib.evolve(pointer_grid, pointer_out, D, dt)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_experiment</span>(<span class="hljs-params">num_iterations</span>):<br>    scratch = np.zeros(grid_shape, dtype=np.double)<br>    grid = np.zeros(grid_shape, dtype=np.double)<br>    block_low = <span class="hljs-built_in">int</span>(grid_shape[<span class="hljs-number">0</span>] * <span class="hljs-number">0.4</span>)<br>    block_high = <span class="hljs-built_in">int</span>(grid_shape[<span class="hljs-number">0</span>] * <span class="hljs-number">0.5</span>)<br>    grid[block_low:block_high, block_low:block_high] = <span class="hljs-number">0.005</span><br>    start = time.time()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_iterations):<br>        evolve(grid, <span class="hljs-number">0.1</span>, scratch)<br>        grid, scratch = scratch, grid<br>    <span class="hljs-keyword">return</span> time.time() - start<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    t = run_experiment(<span class="hljs-number">500</span>)<br>    <span class="hljs-built_in">print</span>(t)<br>    verifier.cleanup_tmpdir()<br></code></pre></td></tr></table></figure><h1 id="使用array-标准库-减少占用-且适合多线程数据传送"><a href="#使用array-标准库-减少占用-且适合多线程数据传送" class="headerlink" title="使用array(标准库)减少占用,且适合多线程数据传送"></a>使用array(标准库)减少占用,且适合多线程数据传送</h1><p>array模块可以高效存储基本数据类型，如整数、浮点数和字符，但不能高效地存储复数和类。它分配了一个连续地内存块存储底层数据。（列表会占用过多内存）</p><h1 id="在内存中高效存储大量文本"><a href="#在内存中高效存储大量文本" class="headerlink" title="在内存中高效存储大量文本"></a>在内存中高效存储大量文本</h1><h2 id="字典树压缩等"><a href="#字典树压缩等" class="headerlink" title="字典树压缩等"></a>字典树压缩等</h2><p>可使用字典树压缩，DAWG，Marisa字典树等(通过共享相同内容部分压缩)。<br>在字符串集合中，很多字符串的某些部分是相同的，使用字典树和DAWG可以减少内存占用。</p><p>DAWG在构建后不能修改，其通过一个的迭代器构建。</p><h2 id="scikit-learn-中FeatureHasher"><a href="#scikit-learn-中FeatureHasher" class="headerlink" title="scikit-learn 中FeatureHasher"></a>scikit-learn 中FeatureHasher</h2><p>DictVectorizer接受一个包含词汇和频次的字典，并将其转换为一个变宽的稀疏矩阵。<br>FeatureHasher将包含词汇和频次的字典转换为宽度固定的稀疏矩阵。</p><h1 id="使用SciPy的稀疏矩阵表示减少内存"><a href="#使用SciPy的稀疏矩阵表示减少内存" class="headerlink" title="使用SciPy的稀疏矩阵表示减少内存"></a>使用SciPy的稀疏矩阵表示减少内存</h1><p>当稀疏度很大时(非0元素很少)，占用的内存少且使用专门的算法，运算效率也高。</p><h1 id="使用异步I-O"><a href="#使用异步I-O" class="headerlink" title="使用异步I&#x2F;O"></a>使用异步I&#x2F;O</h1><p>I&#x2F;O是程序执行的巨大负担。每当从文件读取数据或者将数据写入网络套接字时，代码都必须暂停，以等待内核与外部联系，I&#x2F;O完毕后才能执行后继操作。并发式异步编程，通过在I&#x2F;O等待的时间段内执行其他操作，从而缩短程序的执行时间。</p><h1 id="multiprocessing-Joblib模块"><a href="#multiprocessing-Joblib模块" class="headerlink" title="multiprocessing,Joblib模块"></a>multiprocessing,Joblib模块</h1><p>使用并行的方式进行加速。Joblib专为科学计算设计</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
