<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>最短路径</title>
    <link href="/2025/03/30/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2025/03/30/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><ul><li>对于无权有向图，求解图中源点A至目的点B的最短路径，由于是无权图，最短路径一定是边数最小的路径。可以采用BFS广度优先搜索的形式进行，当搜索到B点时终止，得到的路径为最短路径。(对于图，存在环的情况，BFS遍历时需要对已经访问的节点有所标记，防止回边死循环)。</li><li>对于有权图的最短路径求解。经典算法有Dijkstra算法及Floyd算法。</li></ul><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p>Floyd算法用于求解图中任意两点间的最短距离。（适用于有向，无向图，并且对边权的正负都可求解）。复杂度$o(n)$</p><ol><li>实现思想：定义$f[k][x][y]$表示$x$经过图上的节点$1,\dots,k$至目标节点$y$上的最小距离。若图节点总数为$n$,则$f[n][x][y]$表示该图中$x$至$y$的最短距离。</li><li>对于$f[0][x][y]$,表示$x$至$y$的直接距离。视情况，其值为0或无穷或直接连边的权值长度。</li><li>状态转移求解$f$:<br>$$<br>\begin{equation}<br>f[k][x][y]&#x3D;\min(f[k-1][x][y],f[k-1][x][k]+f[k-1][k][y])<br>\end{equation}<br>$$<br>即不经过$k$点时的最短路径，以及经过$k$点时的最短路径取其一最小值。</li><li>上面的数组在求解过程中可以进行压缩处理，直接适用$f[x][y]$即可，在外层循环控制当前$k$值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br><span class="hljs-keyword">for</span>(x=<span class="hljs-number">1</span>;x&lt;=n;x++)&#123;<br><span class="hljs-keyword">for</span>(y=<span class="hljs-number">1</span>;y&lt;=n;y++)&#123;<br>f[x][y]=std::<span class="hljs-built_in">min</span>(f[x][y],f[x][k]+f[k][y]);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p><strong>说明</strong>: Dijkstra算法可计算源点$s$至图中其他所有点的最短距离以及最短路径。该算法只适用于图的边权非负的情况。因为该算法采用路径长度递增的次序产生最短路径，在算法过程中依赖于非负权值相加得到的路径总权值增加的特性。</p><p><strong>符号</strong>：$s$表示路径的源点。$dis(u)$表示源点$s$至$u$的最短路径长度估计值。$D(u)$表示源点$s$至$u$的最短路径长度的最终值。有$dis(u)\leq D(u)$。<br>$dis(u)$可以使用数组的形式进行记录。当算法迭代完毕收敛时，记录记过即为最终的最短路径结果。</p><p><strong>过程</strong></p><ol><li>图节点分为已经确定最短长度的点集合$S$及未确定最短长度的点集合$T&#x3D;V-S$。初始$S$为起始点$s$，$dis(s)&#x3D;0$</li><li>从$T$中查找节点$u$，满足$dis(u)$最小。将$u$并入$S$集合中。</li><li>根据选择的节点$u$, 更新$T$中点的最短距离记录$dis(v),\forall v\in T$。<br>更新公式:<br>$$<br>\begin{equation}<br>dis(v)&#x3D;\min(dis(v),dis(u)+w(u,v))<br>\newline \quad<br>\text{$w(u,v)$表示$u,v$间的权值}<br>\end{equation}<br>$$</li><li>重复2，3 直至集合$T$为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> v, w; &#125;; <br>vector&lt;edge&gt; e[maxn]; <br><span class="hljs-type">int</span> dis[maxn], vis[maxn]; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> s)</span> </span>&#123; <br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, (n + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)); <br>dis[s] = <span class="hljs-number">0</span>;  <span class="hljs-comment">//初始化信息</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <br><span class="hljs-type">int</span> u = <span class="hljs-number">0</span>, mind = <span class="hljs-number">0x3f3f3f3f</span>; <br><span class="hljs-comment">// 查找T中距离s最小的节点u</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) <br><span class="hljs-comment">// 从集合T中查找</span><br><span class="hljs-keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; mind) <br>u = j, mind = dis[j];<br><span class="hljs-comment">//纳入集合S 中 表示已经求解的最短路径终点</span><br>vis[u] = <span class="hljs-literal">true</span>; <br><span class="hljs-comment">// 更新dis数组中T集合至源点s的最短距离，用于下一步选择次小的边</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ed : e[u]) &#123; <br><span class="hljs-type">int</span> v = ed.v, w = ed.w; <br><span class="hljs-keyword">if</span> (dis[v] &gt; dis[u] + w) <br>dis[v] = dis[u] + w; <br>&#125; <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>改进</strong>：可以使用优先队列记录更新的$dis(v)$以及节点$v$, 当队列为空，即没有$dis$最短路径值得更新时，算法结束。此时复杂度为$O(m\log m)$。(优先队列采用堆进行维护，若堆中节点数为m,其插入查找删除的复杂度为$\log m$)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br><span class="hljs-type">int</span> v,w; <span class="hljs-comment">//边信息  包含下一节点 以及该边的权值</span><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> dis,u; <span class="hljs-comment">//记录起点s至u的距离dis  u为节点编号</span><br>&#125;;<br>vector&lt;edge&gt; e[maxn];  <span class="hljs-comment">//记录每个节点的直接连接边的 下一节点</span><br><span class="hljs-type">int</span> dis[maxn],vis[maxn];<br><span class="hljs-comment">// 优先队列的队头的权值最小</span><br>priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt;&gt; q;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> s)</span></span>&#123;<br><span class="hljs-comment">// n为图的节点总数</span><br><span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,(n<span class="hljs-number">+1</span>)*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>dis[s]=<span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,s&#125;);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> u=q.<span class="hljs-built_in">top</span>().u;<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;<br>vis[u]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br><span class="hljs-comment">// 遍历u节点的直接出 边</span><br><span class="hljs-type">int</span> v=ed.v,w=ed.w; <span class="hljs-comment">//v为u的直接连接点</span><br><span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;<br>dis[v]=dis[u]+w; <span class="hljs-comment">//更新</span><br>q.<span class="hljs-built_in">push</span>(&#123;dis[v],v&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>有向无环图及其应用</title>
    <link href="/2025/03/29/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <url>/2025/03/29/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="有向无环图及其应用"><a href="#有向无环图及其应用" class="headerlink" title="有向无环图及其应用"></a>有向无环图及其应用</h1><ul><li>在编译原理中描述含有公共子式的数据结构</li><li>应用于拓扑排序(Topological Sort)。构建AOV-网(Activity On Vertex Network，顶点表示活动，弧表示活动间的优先关系的有向图)。</li><li>关键路径: 应用于AOE-网(Activity On Edge, 与AOV-网不同的是，AOE中边表示活动，边的权值表示活动的持续时间)。</li></ul><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ul><li><strong>前置知识:偏序</strong>：若集合$X$上的关系$R$满足自反性，传递性以及反对称性，则$R$是$X$上的偏序关系。<ul><li><strong>自反性</strong>: $\forall a \in X,aRa$</li><li><strong>传递性</strong>:$\forall a,b,c \in X,aRb,bRc,\to aRc$</li><li><strong>反对称性</strong>:$\forall a,b \in X,aRb,bRa\to a&#x3D;b$</li></ul></li><li><strong>前置知识:全序</strong>: $R$为$X$上的偏序，若$R$满足连接性,则$R$为$X$上的全序。<ul><li><strong>连接性</strong>: $\forall a,b \in X,要么aRb,要么bRa$</li></ul></li><li><strong>定义</strong>: 由集合的偏序得到该集合的一个全序。</li><li><strong>过程</strong>:<ol><li>在有向图中选择一个没有前驱的节点输出。</li><li>从图中删除该顶点和所有以它为尾的弧。</li><li>重复1，2直到所有顶点全部已经输出或当前图中不存在无前驱的顶点。后一种情况说明图中存在环。</li><li>在删除弧后更新节点的入度时可以使用一个栈或者队列记录入度为0的节点。当栈或者队列为空时算法结束。</li></ol></li></ul><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><ul><li><strong>定义</strong>: 从开始点到结束点最长路径的长度</li><li><strong>符号表示</strong><ul><li>$a_{i}$表示活动，由有向弧$\langle j,k \rangle$表示.</li><li>从$v_{1}$至$v_{i}$的最长路径长度，叫做事件$v_{i}$的最早发生时间。这个时间决定以$v_{i}$为尾的弧的最早开始时间。</li><li>$e_{i}$表示活动$a_{i}$的最早开始时间。$l_{i}$表示$a_{i}$的最迟开始时间。若$l_{i}-e_{i}&#x3D;0$,则$a_{i}$为关键活动。</li><li>求解$e_{i},l_{i}$需要求解最早发生时间$ve_{i}$,最晚发生时间$vl_{i}$.<br>  $$<br>  \begin{equation}<br>  e_{i}&#x3D;ve{j}<br>  \end{equation}<br>  $$<br>  $$<br>  \begin{equation}<br>  l_{i}&#x3D;vl[k]-dut(\left&lt;j,k\right&gt;)<br>  \end{equation}<br>  $$</li><li>向前递推求解$ve$:$ve_{j}&#x3D;\max(ve_{i}+dut(\left&lt;i,j\right&gt;)), \forall \left&lt;i,j\right&gt;\in T$  $T$为所有以$j$节点为弧头的弧集合。</li><li>从$vl_{n-1}&#x3D;ve_{n-1}$开始向后的递推$vl_{i}&#x3D;\min(vl_{j}-dut(\left&lt;i,j\right&gt;)) \quad \forall \langle i,j\rangle \in T$ $T$为所有以$i$节点为弧尾的弧集合。</li><li>$\vdots$</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/03/29/hello-world/"/>
    <url>/2025/03/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
